# Solving 8 Queens problem using Genetic Algorithms

I used the pseudocode given in Russel and Norvig, 2021 to build my Genetic Algorithm to solve the Eight Queens puzzle. Starting with a random population of game states, each state’s fitness, i.e the objective function is calculated and those that are the fittest have the highest chances of reproducing, thus passing on some of their traits to the next generation, with the aim that fitness will improve over successive generations until a solution is found. In the Eight Queens puzzle, the individuals which are closest to being a solution will pass on parts of their board configurations to the next generation to keep getting closer to the solution.

The fitness scores are calculated by counting the number of pairs of queens which are attacking eachother, which is coded into the EightQueenState class, and using this to calculate the number of pairs of queens not attacking eachother. Fitness scores are converted to proportions for the selection process, where they are used to weight each state’s selection probability. Therefore, the fitter the game state is (and closer to being a solution), the more likely it is to be picked to reproduce and pass on its adaptations to the next generation. A number of pairs of parents are chosen, and their game states are crossed over at a random point between 1 and 8 (for the 8 Queen game), creating 2 children, one with the first part of parent a and the second part of parent b, and the other with the first part of parent b and second part of parent a. Parents can be chosen more than once, although a parent cannot be a parent with itself. This means that the fittest states can propagate more in the population. I chose to select n/2 pairs of parents, where n is the size of the population, with a mixing number of 2, as this allows each set of parents to have 2 children each, thus preserving the original population size in all future generations. This means that populations are consistent with the original population input so the algorithm’s performance can be compared with different population sizes. After crossover happens each child’s game state is subject to mutation, much like altering its DNA. Some of the children’s strings are mutated, meaning they are changed to a random number. The occurrence of mutations is random with a probability of 1 in 8. It is common to use a 1/s probability, where s refers to the length of the string. In my second implementation I alter my code to allow it to work with n¬-queens, so I change the mutation rate so it scales with the number of queens. Having a high enough mutation rate is important to prevent the algorithm getting stuck with a population made up of the same strings, which can happen after many generations due to the way that successful individuals propagate. After the next generation of children are created, their fitness scores are evaluated and if there are no solutions to the game parents are selected for the next generation, and this goes on until a solution is found.

To allow n-queen solutions I changed the maximum fitness score so that it was correct for any value of n inputted, and added an error message for n = 2 or 3, as there are no solutions for these values of n. I also chose to alter the makeup of the next generation, by introducing elitism and culling. Elitism is when a specified number of the top performing individuals in the generation are put straight into the next generation’s population, ensuring that the fittest individuals found in the population continue to be used and modified in future generations. In addition, I implemented culling so that the worst performing individuals are removed from the potential set of breeding population. I chose a cut-off of 20%, so that the best 20% of the population are retained for the next generation and the worst 20% are culled from the population before breeding. I thought that this would give a balanced trade-off between elitism and retaining variation within the population. It means that for an 8 Queen game, due to integer rounding down only 1 is chosen for elitism and 1 culled.

The performance of my implementations overall is very inconsistent (the outputs of which can be seen on the Jupyter Notebook underneath my implementations). Test 2 pits each implementation against eachother on the same starting populations. This shows a lot of inconsistency, with the algorithm either finding a solution in a few seconds or taking up to a couple of minutes. For some of the tests, my second implementation finds a solution in many fewer generations, suggesting the elitism and culling helps it to hone in a solution faster. In other examples though it is worse than my first implementation. From looking at the succession of generations it seems that individuals with a high fitness score tend to propagate so much that 1 or 2 unique states dominate the entire population, leading to a lack of variation in recombination. This ultimately means the algorithm has to rely on a mutation to get unstuck. Including elitism and culling reduces variation in the population seems to exacerbate this issue at times, which is probably why the average number of generations over the 10 simulations is almost 1000 more. Tracking average fitness of the population over the course of its generations would be interesting, as I imagine it would increase a lot more quickly in the beginning and then plateau until a mutation allows it to reach a solution.

Ultimately, although a genetic algorithm does work for the 8 queens problem, it does not seem like the most efficient (at least my implementation isn’t). Choosing 2 states to be parents because they are the fittest does not necessarily mean random combinations of them (children) would fit together and itself be fit.

### References

Russell, S. and Norvig, P., 2021. Artificial Intelligence: a Modern Approach, EBook, Global Edition: A Modern Approach [Online]. Harlow, UNITED KINGDOM: Pearson Education.
